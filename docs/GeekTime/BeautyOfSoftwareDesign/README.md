# 软件设计之美
软件设计是一门关注长期变化的学问，是为了减少重复，增加复用
[地址](https://time.geekbang.org/column/intro/100052601)



## 封装
封装的重点在于对象提供了哪些行为，而不是有哪些数据。即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，应该是稳定的；数据是实现，是易变的，应该隐藏起来。

设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter 和 setter 是暴露实现细节的，尽可能不提供，尤其是 setter
封装的要点是行为，数据只是实现细节，而很多人习惯性的写法是面向数据的，这也是导致很多人在设计上缺乏扩展性思考的一个重要原因

## 继承
	要写继承的代码时，先问自己，这是接口继承，还是实现继承？如果是实现继承，那是不是可以写成组合？
	继承分为两种，实现继承和接口继承。实现继承是站在子类的视角看问题，接口继承则是站在父类的视角。
	组合优于继承。
	渠道包含的行为，处理下单，处理支付回调，处理登录，处理获取token，处理上报数据的能力，

## 多态
	只使用封装和继承的编程方式，我们称之为基于对象（Object Based）编程，而只有把多态加进来，才能称之为面向对象（Object Oriented）编程。
	多态（Polymorphism），顾名思义，一个接口，多种形态。同样是一个绘图（draw）的方法，如果以正方形调用，则绘制出一个正方形；如果以圆形调用，则画出的是圆形
	duck-type，虽然实现了相同的接口方法名，但是内部实现不一样，此为多态

	interface Shape 
	{ // 绘图接口 void draw();}

	class Square implements Shape 
	{ void draw() { // 画一个正方形 }}

	class Circle implements Shape 
	{ void draw() { // 画一个圆形 }}

	我们不必考虑具体的形状是什么，只要调用它的绘图方法即可
	接口将变的部分和不变的部分隔离开来。不变的部分就是接口的约定，而变的部分就是子类各自的实现。
	接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。


## 函数式编程
	未完

## 设计原则
### SOLID
### 单一职责原则  SRP
	上述的渠道既包含登录，支付行为，是否要放在一个类里面处理呢？还是分为登录类和支付类
	单一职责针对的是类还是函数呢？一个类肯定不止做一件事，而是为了做一件事而做了许多其他小事，比如为了登录，肯定有获取access_token,有用客户端传入的token换取用户信息，等事件
	单一职责原则讲的并不是一个类只做一件事，它的关注点在于变化，其最初的定义是一个模块应该有且仅有一个变化的原因，后来其定义升级为一个模块应该对一类且仅对一类行为者负责。这个定义从考虑变化升级到考虑变化的来源。

	单一职责原则，本质上体现的还是分离关注点，所以，它与分离关注点的思考角度是一样的，需要我们将模块拆分成更小的粒度。不过，相比于分离关注点，它会更加具体，因为它需要我们考察关注点的来源：不同的行为者。
	一个模块只应该包含来自同一个变化来源的内容
	思考一个类是否符合单一职责，可以看是否提供了不同使用者的功能，

### 开放封闭原则 OCP
	软件实体（类、模块、函数）应该对扩展开放，对修改封闭。

	开放封闭原则向我们描述的是一个结果，就是我们可以不修改代码而仅凭扩展就完成新功能。但是，这个结果的前提是要在软件内部留好扩展点，而这正是需要我们去设计的地方。因为每一个扩展点都是一个需要设计的模型。

	最终结果就是即每次新需求都是新加逻辑处理，而不是修改老的逻辑，if-else一直累加下去，就是修改老代码的典范

### 里式替换原则  LSP
	这里需要如下替换性质：若每个类型 S 的对象 o1，都存在一个类型 T 的对象 o2，使得在所有针对 T 编程的程序 P 中，用 o1 替换 o2 后，程序 P 行为保持不变，则 S 是 T 的子类型。
	用通俗的讲法来说，意思就是，子类型（subtype）必须能够替换其父类型（base type）。	
	如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了 LSP。

	你可能听说过继承要符合 IS-A 的关系，也就是说，如果 A 是 B 的子类，就需要满足 A 是一个 B（A is a B）
	IS-A 的判定是基于行为的，只有行为相同，才能说是满足 IS-A 的关系。

我们讲的设计原则基本上都是关于如何设计一个类。SRP 告诉我们，一个类的变化来源应该是单一的；OCP 说，不要随意修改一个类；LSP 则教导我们应该设计好类的继承关系。

### 接口隔离原则   ISP
	不应强迫使用者依赖于它们不用的方法。
	这个表述看上去很容易理解，就是指在接口中，不要放置使用者用不到的方法
	很多程序员分不清使用者和设计者两个是不同的角色，因为在很多人看来，接口的设计和使用常常是由同一个人完成。这就是角色区分意识的缺失，这种缺失导致我们不能把两种不同的角色区分开来，本质上来说，这也是分离关注点没有做好的一种体现。

	在做软件设计的时候，我们经常考虑的是模型之间如何交互，服务类和应用类如何交互，应用类和配置类如何交互，


### 依赖倒置原则	DIP
	高层模块不应依赖于低层模块，二者应依赖于抽象。
	抽象不应依赖于细节，细节应依赖于抽象。
	我们学习这个原则，最重要的是要理解“倒置”，而要理解什么是“倒置”，就要先理解所谓的“正常依赖”是什么样的。
	不要在一个函数内直接创建一个其他类的实例，这样对长期发展是不利的，因为这种依赖无法替换。
	所以我们需要依赖倒置，即引入
	计算机科学中的所有问题都可以通过引入一个间接层得到解决。
	我们学习的所有原则都是在讲，尽可能把变的部分和不变的部分分开，让不变的部分稳定下来。我们知道，模型是相对稳定的，实现细节则是容易变动的部分。所以，构建出一个稳定的模型层，对任何一个系统而言，都是至关重要的。

	对于任何一个项目而言，了解不同模块的依赖关系是一件很重要的事
	你可以去找一些工具去生成项目的依赖关系图，然后，你就可以用 DIP 作为一个评判标准，去衡量一下你的项目在依赖关系上表现得到底怎么样了。

	理解了 DIP，再来看一些关于依赖的讨论，我们也可以看到不同的角度。比如，循环依赖，有人会说从技术上要如何解决它，但实际上，循环依赖就是设计没有做好的结果，把依赖关系弄错了，才可能会出现循环依赖，先把设计做对，把该有的接口提取出来，依赖就不会循环了。



## 设计模式
	如果用数学来比喻的话，设计原则就像公理，它们是我们讨论各种问题的基础，而设计模式则是定理，它们是在特定场景下，对于经常发生的问题给出的一个可复用的解决方案。
	每一个模式都是一个特定的解决方案，学习设计模式不仅仅要学习代码怎么写，更重要的是要了解模式的应用场景。
	设计模式只是设计原则在特定场景下的应用。

### 简单设计
	KISS, keep it simple, stupid
	YAGNI, you aren't gonna need it
	DRY, don't repeat yourself

### 如何设计
	一个更好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。
	所以，有空的时候，我还是建议你去了解一下 UML，至少你要知道有几种类型的图。这样，以后你在随手画图时，不至于把静态结构和动态交互画在一起。
	从那之后，我也会有意识地去找设计的书去读，会有意识地去反复思考设计的优劣。我经常问自己的一个问题就是，如果我把这段代码重写一遍，我该怎么做。久而久之，我几乎每次都能发现自己代码写得不够好的地方，找到那些值得改进的地方。

### 臭代码
	一个函数内代码超过50行
	函数内嵌套循环超过2层


