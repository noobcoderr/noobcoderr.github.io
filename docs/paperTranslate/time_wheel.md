# 哈希和分层式时轮:实现计时器设施的有效数据结构
作者：George Varghese and Anthony Lauck

## 摘要
​	定时器算法的性能对许多使用定时器进行故障恢复和速率控制的网络协议实现至关重要。实现操作系统计时器模块的传统算法需要O(n)时间来启动或维护计时器，
其中n是未完成计时器的数量:当n很大时，其代价是非常昂贵的。
本文介绍了通过利用环形缓冲器或时间轮,它需要O(1)时间启动，停止，并保持计时器在时间轮的范围内。间隔较大值的两种扩展将被描述，
在第一种方法中，计时器间隔被散列到时间轮上的一个个槽中。
在第二种方法中，使用不同粒度的计时轮层次结构来跨越更大范围的间隔。我们将讨论这两种方案的性能和各种实现折衷。
我们使用我们的方案之一来取代当前的BSD UNIX调用和计时器设施。
我们的新实现可以支持数千个未完成的计时器，而不需要太多的开销。
我们的计时器方案也已在其他操作系统和网络协议包中实现。

## 索引词汇
  Callout facilities, hashed wheels, hierarchical
wheels, protocol implementations, Timers, Timer Facilities

## I. 简介
​	在集中式或分布式系统中，我们需要定时器来完成以下任务：

  **故障恢复**：
	有许多故障无法被异步检测。有些可以通过定期检查(例如，内存损坏)检测到，但是这样的计时器总是超时的。其他故障只能通过在指定期间内缺乏一些积极的操作(例如，消息确认)来推断，如果故障很少发生，则这些计时器很少超时。

  **时间或相对时间为积分概念的算法**：
	示例包括控制某些实体生产速率的算法(过程控制，通信中基于速率的流控制)，调度算法，以及计算机网络中控制数据包生存期的算法。这些计时器几乎总是会过期。当下列任一项为真时，实现计时器模块的算法的性能就会出现问题：  
1、该算法由一个处理器实现，每次硬件时钟滴答作响时就中断，中断开销是相当大的  
2、需要细粒度的计时器  
3、未完成计时器的平均数量很大 

  如果硬件时钟每一秒中断一次主机，并且每一秒之间的间隔是微秒的顺序，那么中断开销是相当大的。
大多数主机操作系统提供粗粒度(毫秒或秒)的计时器。
另外，在某些系统中，更细粒度的计时器位于专用硬件中。
在这两种情况下，计时器算法的性能都将成为一个问题，因为它们决定了启动或停止计时器时产生的延迟以及可以同时执行的计时器的数量。

  例如，考虑分布式系统成员之间的通信。由于消息可能在底层网络中丢失，因此在某种程度上需要计时器来触发重发。
分布式系统中的主机可以有多个未完成的计时器。例如，考虑一个有200个连接的服务器，每个连接有3个计时器。
此外，随着网络扩展到千兆的速度，所需的分辨率和启动和停止计时器的速度都将增加。
最近的几个网络实现(例如[6])已经被调优为每秒发送25000 40000个包

  一些网络实现(例如BSD TCP实现)不使用每个数据包的计时器，相反，整个网络包只使用几个计时器。
BSD TCP实现没有使用两个计时器，因为TCP实现为所有未完成的包维护自己的计时器，并使用单个内核计时器作为时钟来运行自己的计时器。
TCP以最简单的方式维护它的包计时器:每当它的单个内核计时器过期时，它就会清除所有未完成的包计时器。
例如，许多TCP实现使用两个计时器:一个200毫秒的计时器和一个500毫秒的计时器。

  如果计时器的粒度很低且损失很少，那么这种朴素的方法就可以很好地工作。但是，希望提高重传计时器的分辨率以允许更快的恢复。 
例如，亚利桑那大学有一个新的TCP实现，叫做TCP Vegas[4]，它比常用的TCP Reno性能更好。 
TCP Reno在遭受损失时性能较差的原因之一是超时粒度较粗。

  除了更快的错误恢复，细粒度计时器还允许网络协议更精确地测量小时间间隔。
例如，对往返时延的准确估计对于TCP拥塞控制算法[14]和在Wb会议工具中实现的可扩展可靠组播(SRM)框架[11]非常重要[16]。
最后，许多多媒体应用程序经常使用计时器，而且这种应用程序的数量正在增加。 
一个例子可以在Siemens CHANNELS多媒体[3]运行时系统中找到，其中每个音频流使用一个粒度在10到20毫秒之间的计时器。
对于多媒体和其他实时应用程序，在启动和停止计时器的处理时间上有最坏情况的界限是很重要的。

  除了网络应用程序外，过程控制和其他实时应用程序还将受益于大量的细粒度计时器。
此外，系统上的用户数量可能会增加足够大，以导致大量未出色的计时器。
这就是IBM VM/XA SP1操作系统的开发人员引用的原因（用于重新设计计时器设施）[10]。

  在接下来的部分中，我们将描述一系列基于称为计时轮的数据结构的高效计时器实现方案。
我们还将描述基于UNIX实现的性能结果，并调查一些基于本文思想实现了计时器包的系统。

## II.模型
我们的计时器模块模型有以下四个组件例程。

STARTTIMER (Interval, RequestId, ExpiryAction):
  客户端调用这个例程来启动一个计时器，该计时器将在Interval单位时间之后过期。
客户端提供一个RequestId，用于将该计时器与客户端其他未完成计时器区分开来。
最后，客户端可以指定到期时必须采取的操作:例如，调用客户端指定的例程， 或设置事件标志.

STOPTIMER (RequestId):
  这个例程使用它对客户机和RequestId的了解来定位计时器并停止它。

PERTICKBOOKKEEPING：
  让计时器的粒度分为T个单位。然后该例程检查每个单元是否有任何未过期的计时器;
如果是这种情况，它调用STOPTIMER, STOPTIMER反过来调用下一个例程。

EXPIRYPROCESSING：
  这个例程执行在STARTT IMER调用中指定的ExpiryAction。

  前两个例程是在客户机调用时激活的，而后两个例程是在计时器计时时调用的。定时器通常是一个外部硬件时钟

  以下两个性能指标可用于在本文其余部分描述的各种算法之间进行选择。 
它们都是由未完成计时器的平均(或最坏情况)个数参数化的。
  SPACE:定时器模块使用的数据结构所需的内存
  Latency:在timer模块中调用一个例程到它完成之间的时间,假定例程的调用者阻塞直到例程完成。
平均和最坏情况下的延迟都是值得关注的。
    
TABLE 1:网络应用程序认为重要的定时器模块参数的一个例子。

| Routine | Critical Parameter |
| ---- | ---- |
| STARTTIMER | Latency (average and worst-case) |
| STOPTIMER | Latency (average and worst-case) |
| PERTICKBOOKKEEPING | Latency (average) |
| EXPIRYPROCESSING | None |

TABLE 2:三种以前使用的方案的延迟指标。
注意:对于不平衡的树，STOPTIMER是O(1);对于平衡的树，STOPTIMER是O(log (N))
B平衡树实现具有最慢的stopoptimer，因为在删除后需要重新平衡树。


| Scheme           | STARTTIMER | STOPTIMER         | PERTICK |
|------------------|------------|-------------------|----|
| 1                | O(1)       | O(1)              |  O(n)  |
| 2                | O(n)       | O(1)              |  O(1)  |
| 3                | O(log(n))  | O(log(n)) or O(1) |  O(1)  |

  例如，实现传输协议的客户机应用程序可能会发现空间很便宜，timer模块中每个例程的关键参数如表I所示。
  对客户端应用程序重要的性能指标应该用于在计时器算法中进行选择。

## III. 现存的计时器方案
有两种标准方案。

A. Scheme 1—Straightforward：  
  这里[22]STARTT IMER查找一个内存位置并将该位置设置为指定的计时器间隔。
每个单位，PERTICKBOOKKEEPING将减少每个未完成的计时器。
如果任何计时器变为零，则调用EXPIRYPROCESSING。

  这个方案是极快的，除了每时钟簿记。它还为每个未完成的计时器使用一条记录，这是尽可能小的空间
其业绩总结见表二。如果：
  - 杰出的计时器屈指可数
  - 大多数计时器在时钟的几下滴答声内停止
  - PERTICKBOOKKEEPING是由专用硬件以适当的性能完成的

  注意，我们可以存储计时器过期的绝对时间并进行比较，而不是进行减量操作。
这个选项对我们描述的所有计时器方案都有效。它们之间的选择将取决于时间字段的大小、
每条指令的成本以及实现这些算法的机器上的硬件。在本文中，除了描述方案2外，我们将使用Decrement选项

B. Scheme 2—Ordered List  
  这里减少了[22]PERTICKBOOKKEEPING延迟，但降低了STARTTIMER性能。
计时器存储在有序列表中。与方案1不同，我们将存储计时器到期时的绝对时间，而不是到期前的间隔。
此处需要图片

Fig1:用于演示方案2的计时器队列示例。

此处需要图片

Fig2：计时器模块的G/G/INF/INF排队模型。请注意，s（t）是计时器的启动和停止（或到期）之间间隔的密度函数。

  将在最早时间到期的计时器存储在列表的头部。后续的计时器按递增顺序存储，如图1所示。

  在图1中，最低的计时器将在绝对时间10小时，23分钟和12秒结束。

  因为列表是排序的，所以PERTICKBOOKKEEPING只需要增加当前时间，
并将其与列表的头部进行比较。如果它们相等，或者时间更大，则删除该列表元素并调用EXPIRYPROCESSING。
T将继续删除列表头部的元素，直到列表头部的过期时间严格小于当天的时间。

  STARTTIMER 搜索列表以找到插入新计时器的位置。在本例中，STARTT IMER将在第二个和第三个元素之间插入一个到期时间为10:24:01的新计时器

  启动计时器的最坏情况延迟是O(n)。平均延迟取决于计时器间隔的分布(从开始时间到停止时间)，
以及根据对STARTT IMER进行调用的到达进程的分布。

  有趣的是，这可以被建模为一个具有无限服务器的单个队列(图2);这是有效的，
因为队列中的每个计时器在每次计时时都会减少(或服务)。[17]中显示，我们可以使用Little s的结果来获得队列中的平均数字;
另外，新请求看到的计时器队列中元素的剩余时间分布就是计时器间隔分布的剩余生命密度。

  如果到达分布是泊松分布，从头部搜索列表，读取和写入都花费一个单位，
那么负指数分布和均匀定时器间隔分布的插入平均花费[17]为：
    2+2/3n —— 负指数模型
    2+1/2n —— 均匀

  可以使用[17]中的结果来计算其他计时器间隔分布的结果。对于负指数分布，
我们可以通过从后面搜索列表来降低平均成本到2+n/3。事实上，
如果计时器总是插入到列表的后面，那么这种搜索策略将产生1个O(1) STARTTIMER延迟。
例如，如果所有计时器间隔都有相同的值，就会发生这种情况。
然而，对于一般的计时器间隔分布，我们假设插入的平均延迟为O(n)。

TODO此处需要图片

Fig3: 类似于定时器模块和排序模块

  如果列表是双向链接的，则STOPTIMER不需要搜索该列表。当STARTTIMER将计时器插入有序列表时，
它可以存储指向元素的指针。然后，STOPTIMER可以使用该指针在O(1)时间内从双向链表中删除该元素。
这可以被任何计时器方案使用。

  如果Scheme 2是由主机处理器实现的，那么如果有维护单个计时器的硬件支持，
则可以避免每次滴答的中断开销。硬件计时器被设置为在列表最前面的计时器到期的时间到期。
硬件拦截所有的时钟滴答声，只有在计时器实际到期时才中断主机。不幸的是，一些处理器架构不提供此功能
VMS和UNIX在实现计时器模块时都使用类似于Scheme 2的算法。表2总结了两种方案的性能。

  对于空间，方案1需要尽可能小的空间;方案2需要额外的O(n)空间用于队列元素之间的向前和向后指针。

## IV. SORTING TECHNIQUES AND TIME-FLOW MECHANISMS(分类技术和时间流机制)

A. Sorting Algorithms and Priority Queues(排序算法和权重队列)

  scheme 2通过保持计时器列表的排序，减少了PERTICKBOOKKEEPING的延迟，
但却牺牲了STARTTIMER。考虑图3所示的定时器和排序算法之间的关系。
但是，请考虑以下几点:
- 在一个典型的排序中，当排序开始时，所有元素都被输入到模块中;
排序结束时，以有序的顺序输出所有元素。计时器模块执行更动态的排序，
因为元素到达的时间不同，输出的时间也不同。
- 在timer模块中，如果存储间隔，则要排序的元素的值会随着时间的推移而改变。
如果我们按绝对有效时间储存，这就不成立了

  允许动态排序的数据结构是优先队列[7]。优先级队列允许插入和删除元素;
它还允许找到集合中最小的元素。计时器模块可以使用优先队列， 
并且只对最小的计时器元素执行PERTICKBOOKKEEPING。

1) Scheme 3—Tree-Based Algorithms: 
  链表(Scheme 2)是实现优先队列的一种方法。对于大型的、基于树的数据结构更好
对于大型的、基于树的数据结构更好。这些包括不平衡二叉树，堆，后序和末序树，以及左树[7]，[26]
他们试图减少方案2中STARTT IMER的延迟从O(n)到O(log(n))。据报道，在[18]中，
这种差异对于较大的二叉树非常显著，而且不平衡的二叉树比平衡的二叉树开销更小。
不幸的是，非平衡二叉树很容易退化成线性链表;例如，如果插入一组相等的计时器间隔，就会发生这种情况。

  我们将把这些算法合并在一起，作为Scheme 3:基于树的算法。表2总结了方案3的性能。

B. Discrete Event Simulation  

  在离散事件模拟[19]中，系统中的所有状态变化均在离散时间点进行。
此类模拟的重要部分是事件处理程序或时间流机制。当模拟中发生事件时，
它可能会安排未来的事件。这些事件插入了一些杰出事件列表中。模拟通过处理最早的事件进行进行，
这又可能安排进一步的事件。仿真一直持续到事件列表为空或某种条件（例如，时钟最大值时间）

  有两种方法可以找到最早的事件和更新时钟：
1) 最早的事件会立即从某些数据结构(例如，优先级队列[7])中检索出来，
时钟会跳转到这个事件发生的时间。这体现在模拟语言，如GPSS[12]和SIMULA [9]  
2) 在数字电路的仿真中，通常在时钟间隔的倍数时刻考虑事件调度就足够了。
然后，在程序处理一个事件之后，它将时钟变量加1，直到找到当前时间任何未处理的事件。
然后执行事件。这体现在用于数字模拟的语言中，如TEGAS[21]和DECSIM [15]


  我们已经看到，用于实现第一个方法的算法适用于计时器算法:
这些算法包括链表和基于树的结构。更有趣的是，第二种方法的算法也同样适用。
从计时器的角度来看，PERTICKBOOKKEEPING的第二种方法是:按时钟滴答次数递增时钟。
如果任何计时器已经过期，调用EXPIRYPROCESSING。

  实现第二种方法的一种高效且广泛使用的方法是所谓的定时轮[21]、[24]技术。
在此方法中，将计时器插入其中的数据结构是一个列表数组，
其中有一个用于数组范围之外的计时器的溢出列表。

  在图4中，时间被划分为圆。每个圆都是N个时间单位。让当前的周期数保持不变。
如果当前时间指针指向元素i，那么当前时间是S*N+i。与预定在当前周期内到达的事件相对应的事件通知
(如，在时间S*N+i，0到n之间的整数j)插入到数组的第一个元素所指向的列表中。
在当前周期之外发生的任何事件都会插入到溢出列表中。在一个周期内，
模拟会增加当前时间，直到找到非空名单为止。然后，它删除并处理列表中的所有事件。
如果这些时间表在当前周期内的未来事件，则将此类事件插入列表的数组；如果没有，新事件将插入溢出列表中。

  当前的时间指针是递增的Modulo N，当它包装为0时，循环的数量将增加，并检查溢出列表。
将从溢出列表中删除所有将在当前循环中出现的元素，并插入到列表数组中。
这在TEGAS-2中实现[21]。

TODO此处需要图4: 时序轮机构在逻辑仿真中的应用[21]

  阵列可以从概念上将其视为正时轮。每次我们跨越位置时，我们都会通过增加周期数来旋转车轮。
该实现的一个问题是，随着时间的增加在一个周期内，我们向下行驶阵列，
事件记录将插入溢出列表中的可能性更大。其他实现[15]减少（但不能完全避免）这种效果，
通过将车轮旋转到一半的阵列中.

  总之，我们注意到用于数字仿真的时间流算法可以用于实现定时器算法;相反，
计时器算法可以用来实现时间流机制的模拟。然而，也有不同之处需要注意。

- 在数字模拟中，大多数事件发生在当前时间之后的短时间内。
由于计时轮实现很少在溢出列表中放置事件通知，因此它们不会优化这种情况。
对于通用的计时器功能来说，这是不正确的。
- 大多数模拟确保如果两个事件被安排在同一时间发生，它们会按照FIFO顺序被移除。
定时器模块不需要满足这个限制。
- 在轮上穿过空桶代表数字模拟的开销。在计时器模块中，我们必须在每次滴答时增加时钟。
因此，如果是由维护当前时间的同一实体执行的，那么在时钟滴答滴答中跨空桶并不代表显著的额外开销
- 模拟语言假设取消事件通知非常罕见。如果是这样，就足够将通知标记为取消，
并等待事件被安排;此时，调度程序将丢弃该事件。在一个定时器模块中，
STOPTIMER可能会被频繁调用;这种方法可能会导致内存需求无限增长，超出任何时候未完成计时器的数量

  我们将使用下面的计时轮方法作为出发点来描述进一步的计时器算法。

## V. SCHEME 4—BASIC SCHEME

  我们描述了对定时轮算法的一个简单修改。如果我们能够保证所有计时器都设置为小于MaxInterval的时间段，
那么对于STARTT IMER、S TOPTIMER和PERTICKBOOKKEEPING，这种修改后的算法需要O(1)延迟。
设计时器的粒度为1个单位。在图5中，当前时间由一个指向循环缓冲区中元素的指针表示，该元素的尺寸为[0,MaxInterval 1]。

TODO 图5: Scheme 4用于MaxInterval以内的计时器间隔的列表数组。

  为了在当前时间之后的单位设置计时器，我们将(图5)索引到元素i+j(mod MaxInterval)中。
然后将计时器放在将在某个时间过期的计时器列表的前面= 当前时间 + j个时间单位。
每次增加当前计时器指针(mod MaxInterval)并检查所指向的数组元素。
如果元素为0(没有等待过期的计时器列表)，则不再对计时器进行操作。
但如果它是非零，我们对存储在该列表中的所有计时器进行过期处理。
因此，STARTTIMER的延迟为O(1)。PERTICKBOOKKEEPING的成本在O(1)计时器过期时除外，但这是最好的。
如果计时器列表是双向链接的，并且像之前一样，我们存储一个指向每个计时器记录的指针，
那么STOPTIMER的延迟也是O(1)。

  这基本上是一个定时轮方案，轮子转动一个数组元素每一个计时器单元。
而不是旋转每个MaxInterval或MaxInterval/2单位[21]。 这可以确保当前时间的MaxInterval中的所有计时器都将插入列表的数组中；
传统的定时轮算法[15]，[21]不能保证这一点。

  在排序方面，这类似于桶排序[7]，用内存来交换处理。但是，由于计时器每次都改变值，
所以间隔被输入为与当前时间指针的偏移量。如果当前时间指针每一个时刻都增加就足够了。

  桶排序使用M个桶对N个元素元素进行O(M)时间排序，因为所有的桶都要检查。对于大数字M>N来说，这是低效的。
然而，在计时器算法中，关键的观察是，某些实体需要每滴答做一些O(1)工作来更新当前时间。
同样的实体遍历空桶只需要多花费几条指令。与排序不同的是，重要的不是排序N个元素元素的总工作量，
而是每个计时器需要完成的平均(和最坏情况)部分工作。

  但是内存是有限的:很难用2的32次方个字的内存来实现32位的定时器。
一种解决方案是使用该方案和允许的内存在一定范围内实现计时器。大于这个值的计时器是使用Scheme 2实现的
另外，这个方案可以通过两种方式进行扩展，以允许在适度的内存中使用更大的计时器间隔值。

TODO 图6: scheme 5和6用于任意大小计时器的列表数组:基本上是一个哈希表

## VI. EXTENSIONS

A. Extension 1—Hashing

  前面的方案与使用元素值作为索引在数组中插入元素有明显的相似之处。如果内存不足，
我们可以哈希元素值以生成索引。

  例如，如果表的大小是2的幂，那么任意大小的计时器可以很容易地除以表的大小;
剩余的(低序位)被添加到当前时间指针，以产生数组中的索引。除法的结果(高阶位)存储在索引所指向的列表中。

  在图6中，设表大小为256，定时器为32位定时器。除法的余数是最后8位。
设后8位的值为20。那么计时器索引是10(当前时间指针)+20(余数)=30。
然后，将24个高阶位插入到一个由第30个元素指向的列表中。

  还有其他的哈希方法。例如，可以使用任何将计时器值映射到数组索引的函数。
我们将在本小节末尾为我们的选择辩护。

  接下来，有两种方法维护每个列表。

1) Scheme 5—Hash Table With Sorted Lists:

  在这里，每个列表都作为有序列表进行维护，与Scheme 2完全相同。STARTT IMER可能很慢，因为24位数量必须插入到列表中的正确位置。
虽然STARTT IMER的最坏情况的潜伏期仍然是O(n)，平均延迟可以是O(1)，
这将是正确的，如果n<TableSize,如果哈希函数(即TimerValue mod TableSize)在整个表中均匀分布计时器值。
如果是这样，第一个元素插入的列表的平均大小是i-1/TableSize [7]。
由于i≤n<TableSize, STARTTIMER的平均延迟是O(1)。这个散列实际分布的好坏取决于到这个模块的计时器到达分布，以及计时器间隔的分布。

  PERTICKBOOKKEEPING必须增加当前时间指针。如果存储在被指向的数组元素中的值为零，
则不需要再做任何工作。否则，就像在方案2中一样，列表的顶部将递减。如果列表顶部的计时器过期，则调用EXPIRYPROCESSING，并删除列表顶部的元素。
再一次，PERTICKBOOKKEEPING使用O(1)平均延迟和最坏情况下的延迟，
除非多个计时器将在同一时刻到期，这是我们能做到的最好的情况。

  最后，如果每个列表是双向链接的，并且STARTT IMER存储一个指向每个计时器元素的指针，
则STOPTIMER需要时间O(1)。

  一个令人满意的发现是，如果数组大小为1，该方案减少到scheme 2。
在排序方面，Scheme 5类似于对低阶位进行bucket排序，然后对每个bucket所指向的列表进行插入排序[7]

2) Scheme 6—Hash Table with Unsorted Lists:

  如果最坏情况下STARTTIMER延迟为O(n)不可接受，我们可以将每个时间列表维护为无序列表而不是有序列表。
因此，STARTT IMER的最坏情况和平均延迟为O(1)。但现在，每笔记账需要更长的时间。
每计时一次，指针就增加一次(mod TableSize)。如果有一个列表，
我们必须减少数组中每个元素的高阶位，就像方案1一样。但是，如果哈希表具有上述属性，
那么列表的平均大小将为O(1)。

  我们可以对平均行为做出更强的声明——无论散列如何分布。注意，
每执行一次TableSize，我们就会递减所有仍然存在的计时器。因此，对于n个timers，我们平均每次执行n/TableSize大小操作。
如果n<TableSize,那么我们每个时钟单元执行O(1)任务。如果所有n个计时器散列到同一个桶中，
那么每个TableSize刻度都要执行O(n)工作，但对于中间刻度则要执行O(1)工作。

  因此，Scheme 6中的哈希分布只控制PERTICKBOOKKEEPING延迟的方差，而不是平均延迟。
因为PERTICKBOOKKEEPING的最坏情况延迟总是O(n)(所有计时器都在同一时间过期)。
我们认为Scheme 6的哈希函数的选择是不重要的。得到除以2的幂后的余数是便宜的，
因此推荐使用。此外，使用任意散列函数将计时器值映射到数组索引将需要PERTICKBOOKKEEPING
在每个计时器滴答上计算散列，这将使其成本更高。

  我们在附录A中讨论了方案6的实现策略。

B. Extension 2—Exploiting Hierarchy

  基本方案的最后一个扩展利用了层次结构的概念。为了表示1 000 000这个数字，
我们只需要7位数字，而不是1 000 000，因为我们用1 s、10 s、100 s等单位来表示数字。
类似地，要表示32位范围内所有可能的计时器值，我们不需要2的32次方个元素的数组。
相反，我们可以使用多个数组，每个数组的粒度不同。例如，我们可以使用如下四个数组：
- 一个包含100个元素的数组，其中每个元素表示一天。
- 一个包含24个元素的数组，其中每个元素代表一个小时。
- 一个有60个元素的数组，其中每个元素代表一分钟。
- 一个有60个元素的数组，其中每个元素代表一秒。

  因此，我们只需要100+24+60+60=244个位置就可以存储100天的计时器，
而不是100*24*60*60=8.64百万个位置。

TODO 图7：Scheme 7用于更有效地映射时间的列表的分层数组集。

  以图7为例，设当前时间为11天10小时24分钟30秒。为了将计时器设置为50分钟和45秒，
我们首先计算计时器到期的绝对时间，这是11天11小时15分钟15秒。
然后将计时器插入到小时数组中当前小时指针前面的1(11 10小时)元素的列表中。
我们还将剩余的(15分钟15秒)存储在这个位置。我们在图7中展示了这一点，
忽略了在示例中没有变化的天数组。

  seconds数组照常工作:每次硬件时钟滴答作响时，我们递增第二个指针。
如果元素所指向的列表非空，则使用EXPIRYPROCESSING处理列表中的所有元素。
但是，其他三个数组的工作方式略有不同。

  即使服务的用户没有请求计时器，也始终会有用于更新分钟阵列的60秒计时器，
用于更新小时阵列的60分钟计时器，以及用于更新日阵列的24小时计时器。
例如，每当60秒计时器过期时，我们将增加当前的分钟计时器，
对分钟计时器执行任何必需的过期处理，并重新插入另一个60秒计时器。

  回到示例中，如果未停止计时器，则小时计时器最终将达到11。
当小时计时器到达11时，检查列表。expiry处理例程将在minute数组中插入剩余的秒数(15)，
在当前分钟指针(0)之后的15个元素。当然，如果剩余的分钟数为0，我们可以直接转到第二个数组。
此时，表将如图8所示。

  最终，微小数组将到达第15个元素;作为EXPIRYPROCESSING的一部分，
我们将把计时器移到距当前值15秒后的第二个数组中。15秒后，计时器将实际过期，
此时将执行用户指定的EXPIRYPROCESSING。

  这个方案的性能参数是什么？

  STARTTIMER:根据算法的不同，我们可能需要O(m)时间，其中m是层次结构中数组的数量，
以找到插入计时器的正确表，并找到剩余的时间。少量的关卡应该足以在允许的内存范围
内覆盖计时器范围;因此m应该很小(2≤m≤5)。

TODO 图8：在前面的示例中，计时器的小时组件到期后(使用Scheme 7)

  STOPTIMER:同样，如果所有列表都是双链接的，这可以在O(1)时间内完成。

  PERTICKBOOKKEEPING: 将其与Scheme 6中的相应值进行比较是很有用的。
对于足够大的数组大小，两者的平均延迟O(1)相同，但复杂度常数不同。
更精确地说:设T为平均计时器间隔(从开始到停止或失效);设M为可用的数组元素总数;
设m是这个层次的总层数。

  在Scheme 6中为这样一个平均大小的计时器所做的全部工作是 

  c(6)*T/M

  式c(6)中为常数，表示方案6中对高阶位进行减量、索引等操作的代价。
如果计时器以时间T为单位存在，则它将是递减T/M时间。

  在方案7中，它的上界是。

  c(7)*m

  其中，在方案7中，c(7)表示寻找下一个要迁移的列表的成本，以及迁移的成本;
m代表要迁移的列表的最大数量是多少。

  平均计时器的单位时间平均成本就变成了。

  n*c(6)*/M   —— 方案6  
  n*c(7)*m/T  —— 方案7

  计划6或计划7的选择将视乎上述参数而定。由于和不会有很大的不同，
对于较小的值和较大的值，对于STARTT IMER和PERTICKBOOKKEEPING, 
Scheme 6可能比Scheme 7更好。但是，对于较大的值和较小的值，
Scheme 7对于PERTICKBOOKKEEPING具有更好的平均成本(延迟)，
而对于STARTT IMER延迟则具有更大的成本。

  W. Nichols指出，如果允许计时器精度随着层次结构中的级别的增加而降低，
那么我们就不需要在级别之间迁移计时器。例如，在上面的例子中，
我们将四舍五入到最近的小时，只将计时器设置为小时。当小时计时器停止时，
我们执行用户指定的EXPIRYPROCESSING，而不迁移到分钟数组。本质上。
我们现在有不同的计时器模式:一个是小时计时器，一个是分钟计时器，等等。
这进一步降低了PERTICKBOOKKEEPING开销，以损失高达50%的精度为代价
(例如，1分钟和30秒的定时器被四舍五入到1分钟)。另外，
我们还可以通过只允许在相邻列表之间进行一次迁移来提高精度。

  Scheme 7与基数排序[7]有明显的相似之处。我们在附录A中讨论了方案7的实现策略。

## VII. UNIX IMPLEMENTATION

  华盛顿大学的a . Costello实现了[8]，这是BSD UNIX调用和计时器设施的新版本。
当前BSD内核设置或取消计时器的时间与未完成计时器的数量成正比。新的实现基于Scheme 6，
它需要恒定的时间来启动、停止和维护计时器;这就产生了一种高度可伸缩的设计，
可以支持数千个未完成的计时器，而不需要太多的开销。

  在现有的BSD实现中，每个callout都由一个callout结构来表示，
该结构包含一个指向要调用函数的指针(c func)，一个指向函数参数的指针(c arg)，
以及一个以时钟节拍为单位的时间(c time)。未完成的标注保存在一个链表中，
按过期时间排序。每个callout结构的c time成员是差分的，而不是绝对的。
列表中的第一个callout存储从现在到到期的刻度数，列表中的每个后续callout存储自己的到期和到期之间的刻度数。

  在BSD UNIX中，Callouts的设置和取消分别使用名为timeout()和untimeout()的例程。
例程timeout(func, arg, time)注册在指定时间调用func(arg);Untime - out(func, arg)
取消匹配函数和参数的标注。由于calltodo列表必须线性搜索，这两个操作所花费的时间与未完成的callout数量成正比。
在搜索期间，中断被锁定。

  Costello的实现基于上述方案6。不幸的是，BSD中现有的timeout()接口不允许传递句柄，
这在我们所有的方案中都用于快速取消计时器。Costello实现使用了两种解决方案来解决这个问题。
对于使用现有接口的调用，在给定函数指针和参数的情况下，使用哈希表搜索callout。
还实现了第二种解决方案:定义了一个新的接口函数，用于删除以句柄作为唯一参数的callout(unsetcallout())。
这允许现有代码使用旧接口，而新应用程序使用新接口。这两种方法之间的性能差异似乎很小，因此哈希表方法似乎更可取

  在新的实现中，计时器例程保证只在有限的一小段时间内锁定中断。新的实现还扩展了setitimer()接口，
以允许一个进程有多个未完成的计时器，从而减少了用户维护自己的计时器包的需要。
BSD内核的变化很小(增加了548行代码，删除了80行代码)，可以在万维网上使用。
这个新实现的细节在[8];书面报告包含一些这里没有描述的重要实现细节。

A. Performance

  我们测试了Scheme 6的性能(使用Costello实现)。测试利用了新的接口扩展，
该扩展允许单个进程具有多个未完成的标注。我们引用[8]的以下结果。

  在SUN 4/360测试了三个内核。第一个内核将timeout（）接口用于旧的呼叫设施。
第二个内核使用了现有界面，但使用了新的排名设施（和哈希表）。
最后一个内核使用了新的setCallout（）接口（允许手柄）到新的呼叫设施。

  在每个测试中，一个进程创建了许多未执行的计时器，这些计时器设置为遥远未来的随机时间，
从而导致许多未执行的callouts。然后，它创建了更多的计时器，
并反复将其设置为比其他计时器更远的随机时间，
从而导致反复调用timeout()和timeout()(或unsetcallout()和setcallout()，这取决于所使用的是哪个内核)
结果(图9)显示，原始调出工具的时间随未执行的调出数量线性增加，
而替换调出工具的时间与未执行的调出数量保持不变，对于旧接口(使用哈希)和新接口(使用句柄)都是如此。
新接口的性能稍微好一些，并且提供了保证不变的时间操作，但是为了与内核的其他部分兼容，需要使用旧接口。

TODO 图9：BSD UNIX callout实现的实时性能比较。注意，使用计时轮的新标注实现需要恒定的时间。
相比之下，传统的BSD实现需要的时间随着未完成标注的数量线性增加

## VIII. LATER WORK

  本文中描述的工作的初步版本在[25]中首次描述。从那时起，
许多系统都基于这种方法构建了计时器实现，并且对这种基本方法进行了一些扩展。

1) Systems that Use Timing Wheels:   
  一些著名的网络协议实现都使用了本文描述的计时轮思想。其中包括[6]中的快速TCP实现和x内核计时器工具[1]。
[23]中高效的用户级协议实现提到了计时轮的可能使用，但没有实现。 
我们也知道商业网络产品使用计时轮作为其操作系统的一部分。
这些包括DEC的Gigaswitch[20]和Siemens CHANNELS运行时系统[2]

2) Timing Wheel Extensions:  
  Brown[5]将哈希计时轮的思想扩展到他所谓的日历队列主要的区别在于，
日历队列实现还会周期性地调整轮的大小，以减少步进空桶的开销2。
对于计时器应用程序，时钟时间必须在每个时钟滴答的情况下递增
因此，添加一些说明以跨过空桶并不重要。Davison [10]描述了基于日历队列的
IBM VM/XA SP1操作系统的计时器实现。每个tick簿簿记的经验改进
（由于定期调整车轮的大小）似乎不保证调整大小的额外复杂性。

## IX. AN ALGORITHMIC VIEW

  从算法的角度来看，计时轮就是优先级队列[7]。它似乎只是bucket排序技术在优先队列中的一个应用。
但是，桶排序不能有效地用于所有优先级队列实现。 计时轮只在优先队列应用程序中有效地工作，
满足以下有界单调性属性:插入优先队列的任何元素都在最后提取的最小值的最大范围内。

  如果满足这个条件，并且插入的值都是整数，那么我们可以使用一个大小为Max的圆形数组来实现优先队列。
根据新元素的值与当前最小元素的差值，将新元素插入到圆形数组中。指针保留到最后提取的最小值。
要在任意点找到新的最小值，只需向前移动指针，直到找到包含有效元素的数组位置。
这正是在Scheme 4中所做的，其中Max对应于MaxInterval。

  如果不满足单调性条件，很容易看到出了什么问题。如果我们可以插入一个小于最后提取的元素，
那么我们将无法推进指针以找到新的最小值。指针可能必须回溯，导致对整个数组的潜在搜索。

  即使具有单调性条件，轮处理优先队列仍然需要步进空的buck- set。然而，
计时器应用程序的好处是，许多系统无论如何都必须维护一天中的时间，
因此步进空桶的成本分摊到增加时间时钟的现有成本上。
这个例子说明了一个算法在单独考虑时可能具有较差的算法复杂性，
但在作为系统的一部分考虑时可以非常高效，其中部分算法成本可以向其他系统组件收取费用。

  其它算法应用也满足有界单调性条件。例如，对于边权值为整数的图，
最短路径的Dijkstra算法和最小生成树的Prim s算法[7]都满足单调性条件，
即Max等于最大边权值。虽然在[7]之前就已经观察到这两种算法可以从使用线性数组的桶排序中获益，
但线性数组所需的大小应该等于任意两个节点之间最大的最短代价路径的代价。
我们的观察表明，大小等于最大边权值的圆形阵列就足够了。
虽然这是一个温和的观察结果，但它确实减少了使用Dijkstra算法和整数边权[13]的网络实现的内存需求。
据我们所知，有界单调性条件在以前的文献中还没有描述过。

  对于较大的计时器值，散列轮解决方案(Scheme 6)的效率是基于限定计时器数量并进行平摊分析。
这似乎与桶排序没有任何直接的对应关系。分层方案(方案7)基本上使用对数时间插入元素。
因此，它在复杂性上与标准优先级队列实现(如堆[7])相当，但是，常量似乎更适合Scheme 7。

## X. SUMMARY AND CONCLUSIONS

  在本文中，我们研究了排序算法、离散事件模拟中的时间流机制和计时器算法之间的关系。
我们扩展了逻辑仿真中使用的计时轮机制，产生了3种计时器算法(scheme 5 7)，
它们在设置、停止和维护计时器方面具有恒定的复杂性。扩展包括每次时钟滴答转动计时轮、
为每个桶提供单独的溢出列表，以及使用分层的计时轮集(Scheme 7):这些扩展是必要的，
因为逻辑模拟中的调度器和一般计时器模块的需求是不同的。

  在选择方案时，我们认为方案1在某些情况下是合适的，因为它简单、内存使用有限、
启动和停止计时器的速度快。方案2在具有维护时钟和单个计时器的硬件的主机中很有用。
虽然启动计时器需要O(n)时间，但主机不会在每次时钟滴答时被中断。

  在没有硬件支持计时器的主机中，我们认为scheme 2和scheme 3是不合适的，
因为当存在大量未完成计时器时，STARTT IMER的成本太高。
显然，这在具有大量实时活动或有多个开放通信链接的主机中并不罕见。

  当大多数计时器都在当前时间的小范围内时，方案4很有用。例如，
维护自己计时器的网络模块可以使用它。Scheme 5过于依赖散列分布(对于快速STARTT IMER)，
因此通常是有用的。然而，该方案的一个变体已经在X-kernel中实现了[1]。

  对于一般的计时器模块(类似于UNIX或VMS中的操作系统功能，希望在各种环境中都能很好地工作)，
我们推荐使用Scheme 6或Scheme 7。本文中描述的UNIX结果令人鼓舞，
并表明使用Scheme 6可以在低开销的情况下支持数千个未完成的计时器。

  如果有效实现Scheme 6所需要的内存数量是个问题，那么Scheme 7就可以投入使用。
然而，Scheme 7在STARTT IMER中还需要一些指令来找到插入计时器的正确表。

  scheme 6和scheme 7都可以完全或部分(参见附录A)在硬件中实现，
使用一些辅助内存来存储数据结构。如果主机有这样的硬件支持，
那么主机软件将需要时间来启动和停止计时器，而不需要在每次时钟滴答时被中断。

  最后，我们注意到，设计者和实现者都认为使用大量计时器的协议开销很大，
而且性能很差。这是现有实现和操作系统工具的产物。考虑到可以高效地实现大量的计时器，
我们希望这在分布式系统的协议设计中不再是一个问题。

## APPENDIX A HARDWARE ASSIST

  由于处理时钟中断的成本对于细粒度(例如，微秒)计时器来说变得更加重要，
可能需要使用特殊用途的硬件辅助。在极端情况下，我们可以使用一个定时器芯片
来维护所有的数据结构(比如在Scheme 6中)，并且只有在计时器过期时才中断主机软件。

  另一种可能是一个芯片(实际上只是一个计数器)，它步进计时器阵列，
只有当有工作要做时才中断主机。当主机将计时器插入数组元素X所指向的空队列时，
它告诉芯片关于这个新队列的信息。然后芯片标记X为忙碌。和之前一样，
芯片每隔一个时钟就扫描一次计时器阵列。在扫描过程中，当芯片遇到一个繁忙的位置，
它中断主机，并给主机需要处理的队列地址。类似地，当主机从某个队列中删除一个计时器条目
并留下一个空队列时，它需要通知芯片相应的数组位置不再繁忙。

  注意，同步开销是最小的，因为主机可以将实际的计时器队列保存在其内存中，
芯片不需要访问，而芯片可以将计时阵列保存在其内存中，主机不需要访问。
主机和芯片之间的唯一通信是通过中断。

  在方案6中，主机平均每T/M个计时器间隔中断次数，其中为T平均计时器间隔，
M为数组元素的数量。在Scheme 7中，主机在大多数m时候都被中断，
m是层次结构中的级别数。如果T和m很小而M很大，则实现的中断开销可以忽略不计。

  最后，我们注意到传统的硬件定时器芯片使用Scheme 1来维护少量的定时器。
然而，如果scheme 6和7被实现为在单独内存(包含数据结构)上运行的单个芯片，
那么该芯片可以处理的定时器数量就没有先验限制。显然，数组大小需要是参数，
必须在初始化时提供给芯片。

## APPENDIX B SYMMETRIC MULTIPROCESSING

如果主机由一组处理器组成，每个处理器都可以处理对timer模块的调用(对称多处理)，
S. Glaser指出，长时间捆绑一个公共数据结构的算法会降低效率。例如，在方案2中，
当处理器A向有序列表中插入计时器时，其他进程不能处理计时器模块例程，
直到处理器A完成并释放它的信号量。scheme 5 7似乎适合在对称多处理器中实现。
然而，考虑到最近关于在多处理器中保持一致性的技术的研究，这些差异可能并不显著。

## ACKNOWLEDGMENT

B. Spinney建议将方案4扩展到方案5。H. Wilkinson独立地想到了利用层次结构来维护计时器列表。
J. Forecast帮助作者实现了Scheme 6的早期版本。
答:布莱克评论了一个早期的版本，并帮助改进了演示。a . Black, B. Spinney,
H. Wilkinson, S. Glaser, W. Nichols, P. Koning, 
a . Kirby, M. Kempf和C. Kaufman(都在DEC)很高兴与他们讨论这些方案。
作者感谢E. Cooper、M. Bj oorkman、C. Thekath、V. Seidel、B. Souza和
A. Costello提供了关于他们的实现的信息。

## REFERENCES

[1] M. Bj  ̈orkman, personal communication.    
[2] S. Boecking and V. Seidel, “TIP’s protocol run-time system,” in
EFOCN’94, June 1994.  
[3] S. Boecking, V. Seidel, and P. Vindeby, “CHANNELS—A run-time
system for multimedia protocols,” in ICCCN’95, Sept. 1995.  
[4] L. Brakmo, S. O Malley, and L. Peterson, “TCP Vegas: New techniques
for congestion detection and avoidance,” in Proc. ACM SIGCOMM’94,
London, England.  
[5] R. Brown, “Calendar queues: A fast O(1) priority queue implementation
for the simulation event set problem,” Commun. ACM, vol. 31, no. 10,
pp. 1220–1227, Oct. 1988.  
[6] D. D. Clark, V. Jacobson, J. Romkey, and H. Salwen, “An analysis of
TCP processing overhead,” IEEE Commun. Mag., vol. 27, no. 6, pp.
23–29, June 1989.  
[7] T. Cormen, C. Leiserson, and R. Rivest, Introduction to Algorithms.
Cambridge, MA: MIT Press/McGraw-Hill, 1990.  
[8] A. Costello and G. Varghese, “Redesigning the BSD callout and timeout
facilities,” Dept. Computer Science, Washington Univ., St. Louis, MO,
Tech. Rep. 95-23, Sept. 1995.  
[9] O.-J. Dahl, B. Myhrhaug, and K. Nygaard, SIMULA’67 Common Base
Language, Norwegian Computing Center, Forksningveien, 1B, Oslo 3,
Pub. S22.  
[10] G. Davison, “Calendar p’s and q’s,” Commun. ACM, vol. 32, no. 10,
pp. 1241–1242, Oct. 1989.  
[11] S. Floyd, V. Jacobson, S. McCanne, C. Liu, and L. Zhang, “A reliable
multicast framework for light-weight sessions and application level
framing,” in Proc ACM SIGCOMM’95, Boston, MA.  
[12] General Purpose Simulation System 360—User’s Manual, IBM Corp.,
White Plains, NY, Pub. H20-0326, 1968.  
[13] International Organization for Standardization (ISO), “Protocol for pro-
viding the connectionless-model network service,” Draft International
Standard 8473, Mar. 1988.  
[14] V. Jacobson, “ Congestion avoidance and control,” in Proc. ACM
SIGCOMM’88, Stanford, CA.  
[15] M. A. Kearney, “DECSIM: A multi-level simulation system for digital
design,” in 1984 Int. Conf. Computer Design.  
[16] S. Mccanne, “A distributed whiteboard for network conferencing,”
University of California–Berkeley, Computer Networks Term project
CS 268, May 1992.  
[17] C. M. Reeves, “Complexity analysis of event set algorithms,” Computer
J., vol. 27, no. 1, 1984.  
[18] B. Myhrhaug, Sequencing Set Efficiency, Norwegian Computing Center,
Forksningveien, 1B, Oslo 3, Pub. A9.  
[19] A. A. Pritsker and P. J. Kiviat, Simulation with GASP-II. Englewood
Cliffs, NJ: Prentice-Hall, 1969.  
[20] R. Souza et al., “GIGAswitch system: A high-performance packet-
switching platform,” Digital Tech. J., vol. 6, no. 1, Winter 1994.  
[21] S. Szygenda, C. W. Hemming, and J. M. Hemphill, “Time flow
mechanisms for use in digital logic simulations,” in Proc. 1971 Winter
Simulation Conf., New York.  
[22] A. S. Tanenbaum, Computer Networks, 3rd ed. Upper Saddle River,
NJ: Prentice-Hall, 1996.  
[23] C. Thekkath, T. Nguyen, E. Moy, and E. Lazowska, “Implementing
network protocols at user level,” IEEE Trans. Networking, vol. 1, pp.
554–564, Oct. 1993.  
[24] E. Ulrich, “Time-sequenced logical simulation based on circuit delay
and selective tracing of active network paths,” in 1965 ACM Nat. Conf.  
[25] G. Varghese and A. Lauck, “Hashed and hierarchical timing wheels:
Data structures for the efficient implementation of a timer facility,”
in Proc. 11th ACM Symp. Operating Syst. Principles, Nov. 1987, pp.
171–180.  
[26] J. G. Vaucher and P. Duval, “A comparison of simulation event list
algorithms,” Commun. ACM, vol. 18, 1975.  


  George Varghese于1992年获得麻省理工学院(MIT)计算机科学博士学位。

  从1983年到1993年，他在数字网络协议设计部门工作，
并作为DECNET架构和高级开发小组的一部分从事系统研究。
他曾致力于设计DECNET和GIGAswitch产品的协议和算法。
他目前是华盛顿大学圣路易斯分校计算机科学副教授，
在那里他致力于分布式算法和网络实现的高效算法。

  Varghese博士与DEC的同事一起获得了6项专利，另外还有6项专利正在申请中。
他关于自稳定的博士论文被麻省理工学院授予Sprowls计算机科学最佳论文奖。
他是1996年获得ONR青年研究者奖的两名计算机科学家之一。

  Tony Lauck毕业于哈佛大学，剑桥大学，麻省理工学院

  他目前是一名独立的计算机网络顾问。他曾担任Digital Equipment Corporation
  的企业咨询工程师，18年来一直负责Digital的网络架构。

  1990年至1994年，Lauck先生是互联网架构委员会(IAB)的成员。






































































































































































































































































































# 论文地址
https://ieeexplore.ieee.org/abstract/document/650142
http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf
