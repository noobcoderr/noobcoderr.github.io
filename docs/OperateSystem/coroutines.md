# 协程(coroutine-协作式程序cooperation routine)

## 背景
- 我们目前的服务端技术栈`Python`服务和`Go`服务都运用了协程来处理线上并发业务
- 我们团队成员对`Python`和`Go`协程的认知上可能参差不齐
- 面试中经常会问到，而且从网上看完关于协程的文章后有种一团乱麻的感觉

## 目的
1. 彻底搞清楚协程的产生背景，这块要参考最初的论文
2. 协程的实现原理、协程的相比进程线程的优点和缺点
3. 梳理Python和Go协程的基础用法、理解不同高级语言的实现区别
4. hold住面试官的提问

## 前言
为什么要有协程？有多进程多线程还不够嘛？ 我觉得是为了极限压榨单机性能，多进程多线程对资源的利用率还不够高

整理这篇文章的大纲为：
1. 介绍协程是什么，是什么背景下产生的，解决了什么问题，和进程、线程的区别和优缺点
2. 介绍协程的基础实现原理，不同高级语言的实现原理，以及哪些项目使用到了协程
3. 介绍Python的协程和Go的协程的使用，对比二者的实现，优缺点等等

## 协程
**协程的产生背景**


**协程的基础定义**  
考究定义时，要和普通程序进行对比。
- 首先，程序是一段可以被计算机运行的完整代码。
- 其次，子程序(方法、过程、函数)是一个大型程序中的某部分代码，由一个或多个语句块组成，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。

基于以上这两点，我们来梳理子程序和协程的区别

| 特性\类型    | 普通程序(子程序)                         | 协程                                                      |
|----------|-----------------------------------|---------------------------------------------------------|
| 基础       | 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏                | 同子程序，协程是协作式多任务的子程序                                      |
| 调用情况     | 普通程序只能被动调用，只有等被调用了的子程序返回时，才能继续往下走 | 协程可以主动让出执行权，而不仅仅是被动，通过yield，允许执行被挂起与被恢复                 |
| 定义       | 按道基础语法定义                          | 子程序内部加入yield，就变成了生成器(协程)，而去掉yield，就变为了普通的子程序，即协程是特殊的子程序 |
| 和其他同类的关系 | 调用者和被调用者的关系                       | 通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的             |

以上对比数据来源于[协程的wiki](wiki：https://zh.m.wikipedia.org/zh/%E5%8D%8F%E7%A8%8B)

**协程的核心思想**

协程的思想是由程序自身指定中断点，在IO 操作时，程序可以自行中断，主动放弃CPU，此时调度另外的协程继续运行。 当IO 就绪后，再调度此程序从中断点继续向下执行。

**高级语言的协程实现**

Python2: 基于yield

python3: 基于异步io 异步IO asyncio + 事件循环event_loop，异步有什么问题？基于事件驱动，会产生callback hell，但是基本已经被框架和语言层面解决了

php: 使用yield实现生成器来实现协程。[参考](https://www.zhihu.com/question/26966414)



**协程的适用场景**
- IO密集型，web服务器，高并发
- 客户端使用协程批量发送大量请求，压测等，如快速发送10w个请求。
- 服务端使用协程来处理大量客户端请求，高并发，如快速处理10w个并发请求


## Python协程和Go协程的对比
**chatgpt的对比总结**:

`Python`协程和`Go`协程虽然都属于协作式多任务处理的范畴，但在具体实现上有一定的区别，主要包括以下几个方面：

| 区别\语言  | Python                                                                          | Go                                     |
|--------|---------------------------------------------------------------------------------|----------------------------------------|
| 使用方式   | 定义函数前加async，如async def func1()，则定义一个协程函数，使用时将其置入事件循环即可                          | 使用关键字go，如go func1(){} 则新起一个协程运行func1   |
| 实现方式   | 依赖于生成器和协程库(如`asyncio、gevent` 等)来实现,Python3.5之后原生支持了协程，基于asyncio，使用方法是async/awit | Go语言原生支持和实现                            |
| 调度机制   | 依赖于一个事件循环(`Event Loop`)来调度,并采用协作式的调度方式                                          | 由Go运行时系统自己管理和调度，采用`G-M-P`模型来实现并发       |
| 内存管理   | 使用的是`基于栈的内存管理方式`，实现了用户态的线程切换，避免了系统线程切换带来的大量开销                                   | 采用的则是开放式调度器(`M:N 调度方式`)，实现了轻量级的协程切换和调度 |
| 异步编程方式 | 采用的是`async、await`与回调函数的方式来实现异步编程                                                | 使用`channel`和`select`的方式来协调和通信          |
| 支持历史   | 1、生成器；2、tasklet+stackless Python; 3、event_loop + asyncio                        | 语言原生就支持                                |

!>以上信息由chatGPT生成，待自己进行整理辨别

### 使用的对比
此处Python基于3.9版本，Go基于1.17

现在定义一个需要大量IO的场景：多次访问三方接口

**Python创建协程并使用**

?> Python解决GIL问题并利用多核 = 多进程+多协程，而不使用多线程。

```python
import asyncio
async def notice_channel_user_event(url):
    """
    使用协程处理请求
    :return:
    """
    # 模拟请求三方服务的耗时操作
    await asyncio.sleep(1)
    
def main():
    # 启动事件循环并将协程加入事件循环中
    loop = asyncio.get_event_loop()
    tasks = [notice_channel_user_event(i) for i in range(100)]
    loop.run_until_complete(asyncio.wait(tasks))
    loop.close()

if __name__ == '__main__':
    main()
```
以上代码展示了`Python`中基于协程的异步编程模型，使用`async/await`关键字和`asyncio`模块实现异步处理耗时任务。
- 首先定义了一个`async`函数`notice_channel_user_event`代表耗时处理
- 接下来，在主函数`main`中，创建一个事件循环，然后使用列表推导式生成100个协程任务
- 最后使用`loop.run_until_complete(asyncio.wait(tasks))`来将任务列表中的协程对象加入到事件循环中，等待协程的执行完成，最后关闭事件循环

**Go创建协程并使用**

场景仍然同上
```Go
var wg sync.WaitGroup
func notice_channel_user_event(url string) {
	defer wggg.Done()
	// 具体请求三方
	time.sleep(1)
}

func main() {
   // 启动一个协程
   	for i := 1; i <= 100; i++ {
		wggg.Add(1)
   		go notice_channel_user_event()
	}
	wg.Wait()
    return
}
```
以上使用`go`关键字来定义一个协程， 使用`WaitGroup`等待所有协程的执行完成
- 首先，代码定义了一个名为`wg`的`WaitGroup`，用于等待所有协程完成。
- 在`main`函数中，使用一个循环启动了`100`个协程，每个协程都会调用`notice_channel_user_event`函数并传入一个`URL`。在调用`notice_channel_user_event`函数之前，代码会调用`wg.Add(1)`方法，表示要等待一个协程的执行完成
- 在`notice_channel_user_event`函数中，代码使用 defer 语句来确保在函数执行完成后调用`wg.Done()`方法，以标记一个协程的执行完成
总体来说，这段代码的作用是启动`100`个协程并等待它们全部完成，每个协程会在后台请求一个`URL，并在请求完成后标记自己的完成

  
## 参考文章
[当谈论协程时，我们在谈论什么](https://www.developers.pub/article/1125270), 从底层实现说明    
[简单谈谈协程](https://juejin.cn/post/6961414532715511839), 谈到了stackless    
[图解｜揭开协程的神秘面纱](https://zhuanlan.zhihu.com/p/515916638), 图解的形式清晰明了    
[WIKI-协程](https://zh.wikipedia.org/zh-sg/%E5%8D%8F%E7%A8%8B)