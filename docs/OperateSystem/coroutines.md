# 协程(coroutine-协作式程序cooperation routine)


## 背景
- 我们目前的服务端技术栈`Python`服务和`Go`服务都运用了协程来处理线上并发业务
- 我们团队成员对`Python`和`Go`协程的认知上可能参差不齐
- 面试中经常会问到，而且从网上看完关于协程的文章后有种一团乱麻的感觉

## 目的
1. 彻底搞清楚协程的产生背景，这块要参考最初的论文
2. 协程的实现原理、协程的相比进程线程的优点和缺点
3. 梳理Python和Go协程的基础用法、理解不同高级语言的实现区别
4. hold住面试官的提问

## 前言
为什么要有协程？有多进程多线程还不够嘛？ 我觉得是为了极限压榨单机性能，多进程多线程对资源的利用率还不够高

整理这篇文章的大纲为：
1. 介绍协程是什么，是什么背景下产生的，解决了什么问题，和进程、线程的区别和优缺点
2. 介绍协程的基础实现原理，不同高级语言的实现原理，以及哪些项目使用到了协程
3. 介绍Python的协程和Go的协程的使用，对比二者的实现，优缺点等等

## 协程
**协程的产生背景**
协程据传最早源于MELVIN E. CONWAY的一篇论文《Design of a Separable Transition-Diagram Compiler》，该篇论文提出了一种新型的高速、单遍、语法定向的CoBOL编译器设计。    
该实现使用到了一个具体技术：程序分离的协程方法。
>C程序大体上分为预处理、编译、汇编和链接4个阶段。   
> 1、预处理阶段是预处理器将高级语言中的宏展开，去掉代码注释，为调试器添加行号等。   
> 2、编译阶段是将预处理后的高级语言进行词法分析、语法分析、语义分析、优化，最后生成汇编代码。   
> 3、汇编阶段是将汇编代码编译成目标文件，也就是转换成了目标机器平台上的机器指令。   
> 4、链接阶段是将目标文件连接成可执行文件。这里我们只关注汇编和链接这两个阶段。

协程方法的出现应该是应用在第四步，该设计改变了子程序之间的链接方式。该论文关于协程的介绍时提到
>该设计的一个易于适应许多segment配置的特性是其可分离性。如果程序组织结构是可分离的，则它被分成处理模块，这些模块根据以下限制相互通信：  
> （1）模块之间的唯一通信是以离散的信息项形式；  
> （2）每个信息项的流动沿着固定的单向路径；  
> （3）整个程序可以布置，使得输入在左极端，输出在右极端，在两者之间所有在模块之间流动的信息项都具有向右运动的分量。   
> 在这些条件下，每个模块都可以成为协程；也就是说，它可以被编码为一个自主程序，该程序与相邻模块通信，就好像它们是输入或输出子例程一样。
> 因此，协程是所有在同一层级上的子例程，每个协程在行动时都表现得像是主程序，但实际上没有主程序。这个定义没有对协程可能具有的输入和输出数量进行限制。

这里提到了segment，关于segment的解读我参考了[《操作系统真象还原》——0.21 Section和Segment的区别](https://developer.aliyun.com/article/99289)
我对segment的粗浅理解就是: segment应该就是汇编程序的第三步产生的目标文件里的一段功能代码(处理函数/方法)，多个目标文件被链接器链接成可执行文件。

正常的程序是按调用式去链接的，例如funcA调用funcB,那么链接器进行处理时，就会将funcA的目标文件和funcB的目标文件按顺序连接起来，这样就可以达到处理完A再处理B，顺序调用的效果。
但是程序分离的协程方法是将不同的方法设计为了单独的模块，此时如果将方法B定义为一个协程模块的话，此时链接时，应该就会出现funcA执行一部分后切换执行B，B执行一部分后再切换回来执行A。具体怎么链接涉及到汇编语言。

总之该论文的意思就是把整个程序划分为不同的模块，不同的模块处于不同的segment里，即不同的目标文件里，每个模块有读/写操作，而链接器在连接底层的目标文件时，选择将一个模块的读操作的下一条指令连接到下一个模块的写指令


**协程的基础定义**  
考究定义时，要和普通程序进行对比。
- 首先，程序是一段可以被计算机运行的完整代码。
- 其次，子程序(方法、过程、函数)是一个大型程序中的某部分代码，由一个或多个语句块组成，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。

基于以上这两点，我们来梳理子程序和协程的区别

| 特性\类型    | 普通程序(子程序)                         | 协程                                                      |
|----------|-----------------------------------|---------------------------------------------------------|
| 基础       | 一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏                | 同子程序，协程是协作式多任务的子程序                                      |
| 调用情况     | 普通程序只能被动调用，只有等被调用了的子程序返回时，才能继续往下走 | 协程可以主动让出执行权，而不仅仅是被动，通过yield，允许执行被挂起与被恢复                 |
| 定义       | 按道基础语法定义                          | 子程序内部加入yield，就变成了生成器(协程)，而去掉yield，就变为了普通的子程序，即协程是特殊的子程序 |
| 和其他同类的关系 | 调用者和被调用者的关系                       | 通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的             |

以上对比数据来源于[协程的wiki](wiki：https://zh.m.wikipedia.org/zh/%E5%8D%8F%E7%A8%8B)

**协程的核心思想**

协程的思想是由程序自身指定中断点，在IO 操作时，程序可以自行中断，主动放弃CPU，此时调度另外的协程继续运行。 当IO 就绪后，再调度此程序从中断点继续向下执行。

**高级语言的协程实现**

Python2: 基于yield

python3: 基于异步io 异步IO asyncio + 事件循环event_loop，异步有什么问题？基于事件驱动，会产生callback hell，但是基本已经被框架和语言层面解决了

php: 使用yield实现生成器来实现协程。[参考](https://www.zhihu.com/question/26966414)



**协程的适用场景**
- IO密集型，web服务器，高并发
- 客户端使用协程批量发送大量请求，压测等，如快速发送10w个请求。
- 服务端使用协程来处理大量客户端请求，高并发，如快速处理10w个并发请求


## Python协程和Go协程的对比
**chatgpt的对比总结**:

`Python`协程和`Go`协程虽然都属于协作式多任务处理的范畴，但在具体实现上有一定的区别，主要包括以下几个方面：

| 区别\语言  | Python                                                                          | Go                                     |
|--------|---------------------------------------------------------------------------------|----------------------------------------|
| 使用方式   | 定义函数前加async，如async def func1()，则定义一个协程函数，使用时将其置入事件循环即可                          | 使用关键字go，如go func1(){} 则新起一个协程运行func1   |
| 实现方式   | 依赖于生成器和协程库(如`asyncio、gevent` 等)来实现,Python3.5之后原生支持了协程，基于asyncio，使用方法是async/awit | Go语言原生支持和实现                            |
| 调度机制   | 依赖于一个事件循环(`Event Loop`)来调度,并采用协作式的调度方式                                          | 由Go运行时系统自己管理和调度，采用`G-M-P`模型来实现并发       |
| 内存管理   | 使用的是`基于栈的内存管理方式`，实现了用户态的线程切换，避免了系统线程切换带来的大量开销                                   | 采用的则是开放式调度器(`M:N 调度方式`)，实现了轻量级的协程切换和调度 |
| 异步编程方式 | 采用的是`async、await`与回调函数的方式来实现异步编程                                                | 使用`channel`和`select`的方式来协调和通信          |
| 支持历史   | 1、生成器；2、tasklet+stackless Python; 3、event_loop + asyncio                        | 语言原生就支持                                |

!>以上信息由chatGPT生成，待自己进行整理辨别

### 使用的对比
此处Python基于3.9版本，Go基于1.17

现在定义一个需要大量IO的场景：多次访问三方接口

**Python创建协程并使用**

?> Python解决GIL问题并利用多核 = 多进程+多协程，而不使用多线程。

```python
import asyncio
async def notice_channel_user_event(url):
    """
    使用协程处理请求
    :return:
    """
    # 模拟请求三方服务的耗时操作
    await asyncio.sleep(1)
    
def main():
    # 启动事件循环并将协程加入事件循环中
    loop = asyncio.get_event_loop()
    tasks = [notice_channel_user_event(i) for i in range(100)]
    loop.run_until_complete(asyncio.wait(tasks))
    loop.close()

if __name__ == '__main__':
    main()
```
以上代码展示了`Python`中基于协程的异步编程模型，使用`async/await`关键字和`asyncio`模块实现异步处理耗时任务。
- 首先定义了一个`async`函数`notice_channel_user_event`代表耗时处理
- 接下来，在主函数`main`中，创建一个事件循环，然后使用列表推导式生成100个协程任务
- 最后使用`loop.run_until_complete(asyncio.wait(tasks))`来将任务列表中的协程对象加入到事件循环中，等待协程的执行完成，最后关闭事件循环

**Go创建协程并使用**

场景仍然同上
```Go
var wg sync.WaitGroup
func notice_channel_user_event(url string) {
	defer wggg.Done()
	// 具体请求三方
	time.sleep(1)
}

func main() {
   // 启动一个协程
   	for i := 1; i <= 100; i++ {
		wggg.Add(1)
   		go notice_channel_user_event()
	}
	wg.Wait()
    return
}
```
以上使用`go`关键字来定义一个协程， 使用`WaitGroup`等待所有协程的执行完成
- 首先，代码定义了一个名为`wg`的`WaitGroup`，用于等待所有协程完成。
- 在`main`函数中，使用一个循环启动了`100`个协程，每个协程都会调用`notice_channel_user_event`函数并传入一个`URL`。在调用`notice_channel_user_event`函数之前，代码会调用`wg.Add(1)`方法，表示要等待一个协程的执行完成
- 在`notice_channel_user_event`函数中，代码使用 defer 语句来确保在函数执行完成后调用`wg.Done()`方法，以标记一个协程的执行完成
总体来说，这段代码的作用是启动`100`个协程并等待它们全部完成，每个协程会在后台请求一个`URL，并在请求完成后标记自己的完成


## 最后
这篇文章我尝试去读一些出处的论文，但是由于知识储备的问题，很多概念、知识点可能未能读懂或者解读有误，希望读到这篇文章的同学能够指出其中的错误。
  
## 参考文章
[《Design of a Separable Transition-Diagram Compiler》](https://www.melconway.com/Home/pdf/compiler.pdf), 协程出处论文    
[当谈论协程时，我们在谈论什么](https://www.developers.pub/article/1125270), 从底层实现说明    
[简单谈谈协程](https://juejin.cn/post/6961414532715511839), 谈到了stackless    
[图解｜揭开协程的神秘面纱](https://zhuanlan.zhihu.com/p/515916638), 图解的形式清晰明了    
[WIKI-协程](https://zh.wikipedia.org/zh-sg/%E5%8D%8F%E7%A8%8B)